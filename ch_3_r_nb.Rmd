---
title: "Kafli 3: Forvinnsla gagna"
subtitle: 'Applied Predictive Modeling'
author: "Hlynur Hallgrímsson"
date: "15 janúar 2018"
output: html_notebook
---


Í þessari færslu ætla ég að vinna mig í gegnum æfingarnar í þriðja kafla bókarinnar [Applied Predictive Modeling](http://appliedpredictivemodeling.com/) eftir Max Kuhn og Kjell Johnson. 

### 3.1 Gler

Í fyrstu æfingunni notumst við við gagnasett úr *The UC Irvine Machine Learning Repository* sem snýr að greiningu mismunandi tegunda glers út frá ljósbrotsstuðli og samspili 8 mismunandi frumefna: **Na, Mg Al, Si, K, Ca, Ba** og **Fe**. 

Við nálgumst gögnin í `mlbench` pakkann, en auk hans hlöðum við inn öðrum pökkum sem við munum nota við úrvinnslu verkefnisins. 


```{r 3_1_load_packages, warning = FALSE, echo = TRUE}
library(mlbench)
library(AppliedPredictiveModeling)
library(tidyverse)
library(corrplot)
library(caret)
library(viridis)
library(yardstick)
```

Nú þegar við höfum hlaðið inn `mlbench` pakkanum getum við sótt `Glass` gögnin með `data()` aðgerðinni og skoðum strúktúr gagnanna með `str()` fallinu.

```{r 3_1_load_data}
data(Glass)
str(Glass)


```

Við sjáum að `Glass` er gagnarammi með 214 athugunum á 10 breytum. Þar af eru níu talnabreytur og ein þáttabreyta. 

Nú skulum við vinda okkur í verkefnin.

#### Leiðbeiningarnar eru eftirfarandi

* a) Using vizualisations, explore the predictor variables to understand their distributions as well as the relationships between predictors
* b) Do there appear to be any outliers in the data? Are any predictors skewed?
* c) Are there any relevant transformations of one or more predictors that might improve the classification model?



Eins og svo oft er ef til vill best hér að byrja með tíðniriti eða þéttniriti til að sjá dreifingu gilda innan hverrar skýribreytu. 

```{r 3_1_tidnirit}
#Þéttnirit
Glass %>%
  gather(-Type, key = "efni", value = "gildi") %>%
  ggplot(mapping = aes(x = gildi)) +
    geom_density() +
    facet_wrap(~efni, scales = "free")

#Boxplott
Glass %>%
  gather(-Type, key = "efni", value = "gildi") %>%
  ggplot(mapping = aes(x = efni, y = gildi)) +
  geom_boxplot()

```

Við sjáum að þónokkur skekking er til staðar fyrir efnin **Ba, Ca, Fe** og ljósbrotsstuðulinn **RI**. Auk þess eru **K** og **Mg** tvítoppa. Þá virðist vera nokkuð greinilegur útlagi í **K**. 

Því næst skoðum við fylgnirit milli skýribreytanna og notum til þess `corrplot` pakkann sem við höfum nú þegar hlaðið inn. 

```{r 3_1_fylgnirit}
#Skilgreinum hvaða dálkar innihalda skýribreytur svo hægt sé að vísa til þeirra með nafni
skyribreytur <- names(Glass)[1:9]

#Til að laga corrplot er merkingum ása leyft að fara yfir spássíur með eftirfarandi breytingu
par(xpd = TRUE)
#Fylgniplott
fylgni <- cor(Glass[, skyribreytur])
corrplot(fylgni, method = "square", mar = c(1, 1, 1, 1))
```

Við sjáum strax að það er eitthvað um fylgni milli skýribreyta. Sterkust er greinilega jákvæð fylgni milli ljósbrotsstuðulsins **RI** og svo **Ca** og þvínæst neikvæð fylgni milli ljósbrotsstuðulsins **RI** og **Si**. Þess fyrir utan er erfitt að gera sér grein fyrir því út frá litunum hver fylgnin sé í raun. Ef til vill væri þægilegt breyta litunum, og jafnvel að sjá þetta sett fram sem stöplarit. 
  


```{r 3_1_fylgni_stoplarit, warning = FALSE}
fylgni_df <- as_data_frame(fylgni) %>% 
  mutate(names = rownames(fylgni)) %>% 
  gather(-names, key = "key", value = "Fylgni") %>% 
  mutate(var_1 = pmin(names, key), # Setjum breytuna sem er á undan í stafrófinu í dálkinn var_1
         var_2 = pmax(names, key)) %>% # og breytuna sem er á eftir í stafrófinu í dálkinn var_2
  distinct(var_1, var_2, Fylgni) # og er hægt að ná í einstakar samsetningar með distinct

fylgni_df %>%
  mutate(Fylgni = if_else(var_1 == var_2, NA_real_, Fylgni)) %>%
  ggplot(mapping = aes(x = var_1, y = var_2, fill = abs(Fylgni))) +
  geom_tile() +
  scale_fill_viridis()

fylgni_df_utd <- fylgni_df %>% 
  filter(var_1 != var_2) %>% # Fjarlægjum fylgni breytu við sjálfa sig 
  arrange(Fylgni) %>% 
  unite(var_1, var_2, sep = "/", col = "Efni")

nota_palette <- c("#bbbbbb", "#F8766D", "#00BFC4")
throskuldur <- 0.32

fylgni_df_utd %>% 
  mutate(Skipting = case_when(Fylgni > throskuldur ~ "Tiltölulega sterk jákvæð fylgni",
                              Fylgni < -throskuldur ~ "Tiltölulega sterk neikvæð fylgni",
                              TRUE ~ "Minni fylgni")) %>% 
  ggplot(mapping = aes(x = as.numeric(rownames(.)), y = Fylgni, fill = Skipting)) +
  geom_bar(stat = "identity") +
  scale_x_continuous(breaks = NULL, labels = NULL, name = "Samsetningar") +
  scale_fill_manual(values = nota_palette) +
  geom_hline(yintercept = 0)


fylgni_df_utd %>% 
  filter(abs(Fylgni) > 0.32) %>% # Fjarlægjum fylgni sem er ekki meiri en +- 0.32
  mutate(Formerki = if_else(Fylgni >= 0, "Jákvætt", "Neikvætt")) %>% 
  ggplot(mapping = aes(x = as.numeric(rownames(.)), y = Fylgni, fill = Formerki)) +
  geom_bar(stat = "identity") +
  geom_text(mapping = aes(label = Efni, vjust = if_else(Fylgni > 0, -0.9, 1.6))) +
  scale_x_continuous(breaks = NULL, labels = NULL, name = "Samsetningar") +
  geom_hline(yintercept = 0) +
  coord_cartesian(ylim = c(-0.6, 0.9))
```

Þá sjáum við að ef að við notum ljósbrotsstuðul **RI** sem skýribreytu fyrir tegund glersins, þá er efnið **Ca** að fara að veita okkur minnstar viðbótarupplýsingar, og öfugt. Þannig væri líklega okkar fyrsta verk að fjarlægja annað hvort **RI** eða **Ca** sem skýribreytu ef að við vildum fækka fjölda skýribreyta til að einfalda spálíkanið okkar. 

# Forvinnsluaðgerðir
## Til að leiðrétta fyrir skekkingu í dreifingu


Til að leiðrétta fyrir skekkingu í dreifingu skýribreytanna væri ákjósanlegt að geta beitt fyrir sig Box-Cox umbreytingu. Til þess þurfa öll gildi að vera stærri en núll. Því þurfum við að athuga hvort einhver núllgildi eða neikvæð gildi leynist í einhverjum skýribreytanna. Til þess að auðvelda okkur það notum við `map()` fallið úr `purrr` pakkanum. Við höfum þegar hlaðið inn `purrr` hér að ofan um leið og við hlóðum inn `tidyverse` pakkasamstæðunni. 

```{r 3_1_null_e_neikvaett}
Glass[, skyribreytur] %>% 
map(~sum(. <= 0)) %>% unlist()
```

Einungis **RI, Na, Al, Si** og **Ca** innihalda bara jákvæð gildi, en hin ekki. Við sjáum því strax að Box-Cox umbreyting er ekki valkostur fyrir allar skýribreyturnar, né þá heldur log-umbreyting. Þá prófum við Yeo-Johnson umbreytingu, en hún er ekki alls ósvipuð Box-Cox nema fyrir það að gildi mega vera neikvæð eða núll. Raunar er Yeo-Johnson umbreytingin í reynd Box-Cox umbreyting í þeim tilfellum þar sem öll gildi breytu eru jákvæð. Til þess að kalla fram Yeo-Johnson umbreytingu getum við notað `preProcess()` fallið úr `caret` pakkanum, sem skrifaður er af Max Kuhn, öðrum höfundi bókarinnar.

```{r 3_1_yj}
pp_object_Glass <- preProcess(Glass, method = c("center", "scale", "YeoJohnson"))

glass_yj <- predict(pp_object_Glass, Glass)

pp_object_Glass_cs <- preProcess(Glass, method = c("center", "scale"))

glass_cs <- predict(pp_object_Glass_cs, Glass)

```

Prófum sama þéttnirit og áður, nú eftir Yeo-Johnson umbreytingu.

```{r}
glass_yj %>% 
  gather(-Type, key = "efni", value = "gildi") %>%
  ggplot(mapping = aes(x = gildi)) +
    geom_density() +
    facet_wrap(~efni, scales = "free")

glass_yj_tidy <- glass_yj %>% 
  gather(-Type, key = "efni", value = "gildi")

glass_cs_tidy <- glass_cs %>% 
    gather(-Type, key = "efni", value = "gildi")

glass_saman <- bind_rows("Fyrir" = glass_cs_tidy, "Eftir" = glass_yj_tidy, .id = "Y-J umbreyting")

glass_saman %>% 
  ggplot(mapping = aes(x = gildi, color = `Y-J umbreyting`, fill = `Y-J umbreyting`)) +
    geom_density(alpha = 0.2) +
    facet_wrap(~efni, scales = "free")


```

# Hefur umbreytingin einhver áhrif á spágetu?

```{r}
train_ind <- caret::createDataPartition(y = glass_cs$Type, p = 0.85, list = FALSE)
pred_vars <- 1:9

training_set_raw <- Glass[train_ind, ]
training_set <- glass_cs[train_ind, ]
training_set_yj <- glass_yj[train_ind, ]

test_set_raw <- Glass[train_ind, ]
test_set <- glass_cs[-train_ind, ]
test_set_yj <- glass_yj[-train_ind, ]
```


```{r}
library(doParallel)
cl <- makeCluster(7)
registerDoParallel(cl)

upph <- proc.time()

mod_xgb <- train(x = training_set[, pred_vars], y = training_set$Type,
                 method = "xgbTree",
                 trControl = trainControl(
                   method = "repeatedcv", number = 5,
                   repeats = 5,
                   allowParallel = TRUE
                 )
)

timi <- proc.time() - upph

stopCluster(cl)

```


```{r}
library(doParallel)
cl <- makeCluster(7)
registerDoParallel(cl)

upph <- proc.time()

mod_xgb_yj <- train(x = training_set_yj[, pred_vars], y = training_set_yj$Type,
                 method = "xgbTree",
                 trControl = trainControl(
                   method = "repeatedcv", number = 5,
                   repeats = 5,
                   allowParallel = TRUE
                 )
)

timi <- proc.time() - upph

stopCluster(cl)
```


```{r}
test_set %>% 
  mutate(Type_pred = predict(mod_xgb, .)) %>% 
  yardstick::metrics(Type, Type_pred)

test_set_yj %>% 
  mutate(Type_pred = predict(mod_xgb_yj, .)) %>% 
  yardstick::metrics(Type, Type_pred)

```

```{r}
training_set_raw$Type <- as.factor(training_set_raw$Type)
levels(training_set_raw$Type) <- c("One", "Two", "Three", "Five", "Six", "Seven")

cl <- makeCluster(7)
registerDoParallel(cl)

library(caretEnsemble)
control <- trainControl(method="repeatedcv", number=10, repeats=3, savePredictions="final", classProbs=TRUE)
algorithmList <- c('knn', 'treebag', 'rf', 'rpart', 'svmRadial') #'rpart', 'svmRadial', 'amdai', 'nnet', 'AdaBag', 'bstTree'
#Include   'xgbTree',  'C5.0'
models_raw <- caretList(Type~., data=training_set_raw, trControl=control, methodList=algorithmList)
results_raw <- resamples(models_raw)

stopCluster(cl)
```



```{r}
training_set$Type <- as.factor(training_set$Type)
levels(training_set$Type) <- c("One", "Two", "Three", "Five", "Six", "Seven")

cl <- makeCluster(7)
registerDoParallel(cl)

library(caretEnsemble)
control <- trainControl(method="repeatedcv", number=10, repeats=3, savePredictions="final", classProbs=TRUE)
algorithmList <- c('knn', 'treebag', 'rf', 'rpart', 'svmRadial') #'rpart', 'svmRadial', 'amdai', 'nnet', 'AdaBag', 'bstTree'
#Include   'xgbTree',  'C5.0'
models <- caretList(Type~., data=training_set, trControl=control, methodList=algorithmList)
results <- resamples(models)

stopCluster(cl)
```


```{r}
training_set_yj$Type <- as.factor(training_set_yj$Type)
levels(training_set_yj$Type) <- c("One", "Two", "Three", "Five", "Six", "Seven")

cl <- makeCluster(7)
registerDoParallel(cl)

library(caretEnsemble)
control <- trainControl(method="repeatedcv", number=10, repeats=3, savePredictions="final", classProbs=TRUE)
algorithmList <- c('knn', 'treebag', 'rf', 'rpart', 'svmRadial') #'rpart', 'svmRadial', 'amdai', 'nnet', 'AdaBag', 'bstTree'
#Include   'xgbTree',  'C5.0'
models_yj <- caretList(Type~., data=training_set_yj, trControl=control, methodList=algorithmList)
results_yj <- resamples(models_yj)

stopCluster(cl)
```


```{r}
library(broom)
list("yj" = broom::tidy(summary(results_yj$values)),
     "raw" = broom::tidy(summary(results_raw$values)),
     "cs" = broom::tidy(summary(results$values))) %>%
  map(~filter(., 
              str_detect(Var2, "Accuracy"),
              str_detect(Freq, "Mean"))) %>% 
  map(~mutate(., 
              Freq = str_remove(Freq, "Mean   :"),
              Var2 = str_remove(Var2, "~Accuracy"))) %>%
  map(~select(.,
              -Var1)) %>% 
  map(~mutate_all(.,
                  str_trim, side = "both")) %>%
  map(~rename(., 
              model = Var2,
              accuracy = Freq)) %>% 
  bind_rows(.id = "preprocess") %>% 
  mutate(preprocess = fct_relevel(preprocess, "raw")) %>% 
  ggplot(aes(x = preprocess, y = accuracy, fill = preprocess)) +
  geom_col() +
  facet_wrap(~model) 

```

